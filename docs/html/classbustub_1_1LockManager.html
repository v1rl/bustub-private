<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BusTub: bustub::LockManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BusTub
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebustub.html">bustub</a></li><li class="navelem"><a class="el" href="classbustub_1_1LockManager.html">LockManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classbustub_1_1LockManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bustub::LockManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="lock__manager_8h_source.html">lock_manager.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for bustub::LockManager:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classbustub_1_1LockManager__coll__graph.svg" width="307" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager_1_1LockRequest.html">LockRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager_1_1LockRequestQueue.html">LockRequestQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae9072590d90b9b3861d415052c4872d3"><td class="memItemLeft" align="right" valign="top"><a id="ae9072590d90b9b3861d415052c4872d3"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>LockMode</b> { <br />
&#160;&#160;<b>SHARED</b>
, <b>EXCLUSIVE</b>
, <b>INTENTION_SHARED</b>
, <b>INTENTION_EXCLUSIVE</b>
, <br />
&#160;&#160;<b>SHARED_INTENTION_EXCLUSIVE</b>
<br />
 }</td></tr>
<tr class="separator:ae9072590d90b9b3861d415052c4872d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a6999ff8d30e8f121741d074cb88775"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#a9a6999ff8d30e8f121741d074cb88775">LockManager</a> ()=default</td></tr>
<tr class="separator:a9a6999ff8d30e8f121741d074cb88775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d98acacc57c96f93d2a0a2c5361a99"><td class="memItemLeft" align="right" valign="top"><a id="af8d98acacc57c96f93d2a0a2c5361a99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>StartDeadlockDetection</b> ()</td></tr>
<tr class="separator:af8d98acacc57c96f93d2a0a2c5361a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb7aa117f151b0033d96c247292d375"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#a2fb7aa117f151b0033d96c247292d375">LockTable</a> (<a class="el" href="classbustub_1_1Transaction.html">Transaction</a> *txn, LockMode lock_mode, const <a class="el" href="namespacebustub.html#a3571cdcf7aa43bd929669794e75cbc48">table_oid_t</a> &amp;oid) noexcept(false) -&gt; bool</td></tr>
<tr class="separator:a2fb7aa117f151b0033d96c247292d375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c917de275498c22f53138355787447"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#a89c917de275498c22f53138355787447">UnlockTable</a> (<a class="el" href="classbustub_1_1Transaction.html">Transaction</a> *txn, const <a class="el" href="namespacebustub.html#a3571cdcf7aa43bd929669794e75cbc48">table_oid_t</a> &amp;oid) -&gt; bool</td></tr>
<tr class="separator:a89c917de275498c22f53138355787447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988be485d32619bd5165855c9cdaf0cf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#a988be485d32619bd5165855c9cdaf0cf">LockRow</a> (<a class="el" href="classbustub_1_1Transaction.html">Transaction</a> *txn, LockMode lock_mode, const <a class="el" href="namespacebustub.html#a3571cdcf7aa43bd929669794e75cbc48">table_oid_t</a> &amp;oid, const <a class="el" href="classbustub_1_1RID.html">RID</a> &amp;rid) -&gt; bool</td></tr>
<tr class="separator:a988be485d32619bd5165855c9cdaf0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd25bf2d1fd916e5d0900fdcee196aa2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#acd25bf2d1fd916e5d0900fdcee196aa2">UnlockRow</a> (<a class="el" href="classbustub_1_1Transaction.html">Transaction</a> *txn, const <a class="el" href="namespacebustub.html#a3571cdcf7aa43bd929669794e75cbc48">table_oid_t</a> &amp;oid, const <a class="el" href="classbustub_1_1RID.html">RID</a> &amp;rid, bool force=false) -&gt; bool</td></tr>
<tr class="separator:acd25bf2d1fd916e5d0900fdcee196aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df679feece998f685f834d98044e289"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#a5df679feece998f685f834d98044e289">AddEdge</a> (txn_id_t t1, txn_id_t t2) -&gt; void</td></tr>
<tr class="separator:a5df679feece998f685f834d98044e289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84ac003c1fda4f5a32fc3ecfc98bc80"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#af84ac003c1fda4f5a32fc3ecfc98bc80">RemoveEdge</a> (txn_id_t t1, txn_id_t t2) -&gt; void</td></tr>
<tr class="separator:af84ac003c1fda4f5a32fc3ecfc98bc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f9957ef501be56f430ab93457dd17f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#ab3f9957ef501be56f430ab93457dd17f">HasCycle</a> (txn_id_t *txn_id) -&gt; bool</td></tr>
<tr class="separator:ab3f9957ef501be56f430ab93457dd17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe347095eb5d3210b710834fe962378c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#abe347095eb5d3210b710834fe962378c">GetEdgeList</a> () -&gt; std::vector&lt; std::pair&lt; txn_id_t, txn_id_t &gt;&gt;</td></tr>
<tr class="separator:abe347095eb5d3210b710834fe962378c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46d2abc2ed8ffa17934036d87e50d08"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1LockManager.html#ac46d2abc2ed8ffa17934036d87e50d08">RunCycleDetection</a> () -&gt; void</td></tr>
<tr class="separator:ac46d2abc2ed8ffa17934036d87e50d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4a17fdd331a495258d1bde87b1e39635"><td class="memItemLeft" align="right" valign="top"><a id="a4a17fdd331a495258d1bde87b1e39635"></a>
<a class="el" href="classbustub_1_1TransactionManager.html">TransactionManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>txn_manager_</b></td></tr>
<tr class="separator:a4a17fdd331a495258d1bde87b1e39635"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classbustub_1_1LockManager.html">LockManager</a> handles transactions asking for locks on records. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a6999ff8d30e8f121741d074cb88775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6999ff8d30e8f121741d074cb88775">&#9670;&nbsp;</a></span>LockManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bustub::LockManager::LockManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new lock manager configured for the deadlock detection policy. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5df679feece998f685f834d98044e289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df679feece998f685f834d98044e289">&#9670;&nbsp;</a></span>AddEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bustub::LockManager::AddEdge </td>
          <td>(</td>
          <td class="paramtype">txn_id_t&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">txn_id_t&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an edge from t1 -&gt; t2 from waits for graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>transaction waiting for a lock </td></tr>
    <tr><td class="paramname">t2</td><td>transaction being waited for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe347095eb5d3210b710834fe962378c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe347095eb5d3210b710834fe962378c">&#9670;&nbsp;</a></span>GetEdgeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::LockManager::GetEdgeList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::vector&lt;std::pair&lt;txn_id_t, txn_id_t&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all edges in current waits_for graph </dd></dl>

</div>
</div>
<a id="ab3f9957ef501be56f430ab93457dd17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f9957ef501be56f430ab93457dd17f">&#9670;&nbsp;</a></span>HasCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::LockManager::HasCycle </td>
          <td>(</td>
          <td class="paramtype">txn_id_t *&#160;</td>
          <td class="paramname"><em>txn_id</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the graph has a cycle, returning the newest transaction ID in the cycle if so. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">txn_id</td><td>if the graph has a cycle, will contain the newest transaction ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the graph has no cycle, otherwise stores the newest transaction ID in the cycle to txn_id </dd></dl>

</div>
</div>
<a id="a988be485d32619bd5165855c9cdaf0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988be485d32619bd5165855c9cdaf0cf">&#9670;&nbsp;</a></span>LockRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::LockManager::LockRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbustub_1_1Transaction.html">Transaction</a> *&#160;</td>
          <td class="paramname"><em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LockMode&#160;</td>
          <td class="paramname"><em>lock_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebustub.html#a3571cdcf7aa43bd929669794e75cbc48">table_oid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbustub_1_1RID.html">RID</a> &amp;&#160;</td>
          <td class="paramname"><em>rid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire a lock on rid in the given lock_mode. If the transaction already holds a lock on the row, upgrade the lock to the specified lock_mode (if possible).</p>
<p>This method should abort the transaction and throw a TransactionAbortException under certain circumstances. See [LOCK_NOTE] in header file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txn</td><td>the transaction requesting the lock upgrade </td></tr>
    <tr><td class="paramname">lock_mode</td><td>the lock mode for the requested lock </td></tr>
    <tr><td class="paramname">oid</td><td>the table_oid_t of the table the row belongs to </td></tr>
    <tr><td class="paramname">rid</td><td>the <a class="el" href="classbustub_1_1RID.html">RID</a> of the row to be locked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the upgrade is successful, false otherwise </dd></dl>

</div>
</div>
<a id="a2fb7aa117f151b0033d96c247292d375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb7aa117f151b0033d96c247292d375">&#9670;&nbsp;</a></span>LockTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::LockManager::LockTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbustub_1_1Transaction.html">Transaction</a> *&#160;</td>
          <td class="paramname"><em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LockMode&#160;</td>
          <td class="paramname"><em>lock_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebustub.html#a3571cdcf7aa43bd929669794e75cbc48">table_oid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>oid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[LOCK_NOTE]</p>
<p>GENERAL BEHAVIOUR: Both <a class="el" href="classbustub_1_1LockManager.html#a2fb7aa117f151b0033d96c247292d375">LockTable()</a> and <a class="el" href="classbustub_1_1LockManager.html#a988be485d32619bd5165855c9cdaf0cf">LockRow()</a> are blocking methods; they should wait till the lock is granted and then return. If the transaction was aborted in the meantime, do not grant the lock and return false.</p>
<p>MULTIPLE TRANSACTIONS: <a class="el" href="classbustub_1_1LockManager.html">LockManager</a> should maintain a queue for each resource; locks should be granted to transactions in a FIFO manner. If there are multiple compatible lock requests, all should be granted at the same time as long as FIFO is honoured.</p>
<p>SUPPORTED LOCK MODES: Table locking should support all lock modes. Row locking should not support Intention locks. Attempting this should set the TransactionState as ABORTED and throw a TransactionAbortException (ATTEMPTED_INTENTION_LOCK_ON_ROW)</p>
<p>ISOLATION LEVEL: Depending on the ISOLATION LEVEL, a transaction should attempt to take locks:</p><ul>
<li>Only if required, AND</li>
<li>Only if allowed</li>
</ul>
<p>For instance S/IS/SIX locks are not required under READ_UNCOMMITTED, and any such attempt should set the TransactionState as ABORTED and throw a TransactionAbortException (LOCK_SHARED_ON_READ_UNCOMMITTED).</p>
<p>Similarly, X/IX locks on rows are not allowed if the the <a class="el" href="classbustub_1_1Transaction.html">Transaction</a> State is SHRINKING, and any such attempt should set the TransactionState as ABORTED and throw a TransactionAbortException (LOCK_ON_SHRINKING).</p>
<p>REPEATABLE_READ: The transaction is required to take all locks. All locks are allowed in the GROWING state No locks are allowed in the SHRINKING state</p>
<p>READ_COMMITTED: The transaction is required to take all locks. All locks are allowed in the GROWING state Only IS, S locks are allowed in the SHRINKING state</p>
<p>READ_UNCOMMITTED: The transaction is required to take only IX, X locks. X, IX locks are allowed in the GROWING state. S, IS, SIX locks are never allowed</p>
<p>MULTILEVEL LOCKING: While locking rows, Lock() should ensure that the transaction has an appropriate lock on the table which the row belongs to. For instance, if an exclusive lock is attempted on a row, the transaction must hold either X, IX, or SIX on the table. If such a lock does not exist on the table, Lock() should set the TransactionState as ABORTED and throw a TransactionAbortException (TABLE_LOCK_NOT_PRESENT)</p>
<p>LOCK UPGRADE: Calling Lock() on a resource that is already locked should have the following behaviour:</p><ul>
<li>If requested lock mode is the same as that of the lock presently held, Lock() should return true since it already has the lock.</li>
<li>If requested lock mode is different, Lock() should upgrade the lock held by the transaction.</li>
<li>Basically there should be three steps to perform a lock upgrade in general<ul>
<li>1. Check the precondition of upgrade</li>
<li>2. Drop the current lock, reserve the upgrade position</li>
<li>3. Wait to get the new lock granted</li>
</ul>
</li>
</ul>
<p>A lock request being upgraded should be prioritized over other waiting lock requests on the same resource.</p>
<p>While upgrading, only the following transitions should be allowed: IS -&gt; [S, X, IX, SIX] S -&gt; [X, SIX] IX -&gt; [X, SIX] SIX -&gt; [X] Any other upgrade is considered incompatible, and such an attempt should set the TransactionState as ABORTED and throw a TransactionAbortException (INCOMPATIBLE_UPGRADE)</p>
<p>Furthermore, only one transaction should be allowed to upgrade its lock on a given resource. Multiple concurrent lock upgrades on the same resource should set the TransactionState as ABORTED and throw a TransactionAbortException (UPGRADE_CONFLICT).</p>
<p>BOOK KEEPING: If a lock is granted to a transaction, lock manager should update its lock sets appropriately (check <a class="el" href="transaction_8h_source.html">transaction.h</a>)</p>
<p>You probably want to consider which type of lock to directly apply on table when implementing executor later [UNLOCK_NOTE]</p>
<p>GENERAL BEHAVIOUR: Both <a class="el" href="classbustub_1_1LockManager.html#a89c917de275498c22f53138355787447">UnlockTable()</a> and <a class="el" href="classbustub_1_1LockManager.html#acd25bf2d1fd916e5d0900fdcee196aa2">UnlockRow()</a> should release the lock on the resource and return. Both should ensure that the transaction currently holds a lock on the resource it is attempting to unlock. If not, <a class="el" href="classbustub_1_1LockManager.html">LockManager</a> should set the TransactionState as ABORTED and throw a TransactionAbortException (ATTEMPTED_UNLOCK_BUT_NO_LOCK_HELD)</p>
<p>Additionally, unlocking a table should only be allowed if the transaction does not hold locks on any row on that table. If the transaction holds locks on rows of the table, Unlock should set the <a class="el" href="classbustub_1_1Transaction.html">Transaction</a> State as ABORTED and throw a TransactionAbortException (TABLE_UNLOCKED_BEFORE_UNLOCKING_ROWS).</p>
<p>Finally, unlocking a resource should also grant any new lock requests for the resource (if possible).</p>
<p>TRANSACTION STATE UPDATE Unlock should update the transaction state appropriately (depending upon the ISOLATION LEVEL) Only unlocking S or X locks changes transaction state.</p>
<p>REPEATABLE_READ: Unlocking S/X locks should set the transaction state to SHRINKING</p>
<p>READ_COMMITTED: Unlocking X locks should set the transaction state to SHRINKING. Unlocking S locks does not affect transaction state.</p>
<p>READ_UNCOMMITTED: Unlocking X locks should set the transaction state to SHRINKING. S locks are not permitted under READ_UNCOMMITTED. The behaviour upon unlocking an S lock under this isolation level is undefined.</p>
<p>BOOK KEEPING: After a resource is unlocked, lock manager should update the transaction's lock sets appropriately (check <a class="el" href="transaction_8h_source.html">transaction.h</a>)</p>
<p>Acquire a lock on table_oid_t in the given lock_mode. If the transaction already holds a lock on the table, upgrade the lock to the specified lock_mode (if possible).</p>
<p>This method should abort the transaction and throw a TransactionAbortException under certain circumstances. See [LOCK_NOTE] in header file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txn</td><td>the transaction requesting the lock upgrade </td></tr>
    <tr><td class="paramname">lock_mode</td><td>the lock mode for the requested lock </td></tr>
    <tr><td class="paramname">oid</td><td>the table_oid_t of the table to be locked in lock_mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the upgrade is successful, false otherwise </dd></dl>

</div>
</div>
<a id="af84ac003c1fda4f5a32fc3ecfc98bc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84ac003c1fda4f5a32fc3ecfc98bc80">&#9670;&nbsp;</a></span>RemoveEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bustub::LockManager::RemoveEdge </td>
          <td>(</td>
          <td class="paramtype">txn_id_t&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">txn_id_t&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an edge from t1 -&gt; t2 from waits for graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>transaction waiting for a lock </td></tr>
    <tr><td class="paramname">t2</td><td>transaction being waited for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac46d2abc2ed8ffa17934036d87e50d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46d2abc2ed8ffa17934036d87e50d08">&#9670;&nbsp;</a></span>RunCycleDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bustub::LockManager::RunCycleDetection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs cycle detection in the background. </p>

</div>
</div>
<a id="acd25bf2d1fd916e5d0900fdcee196aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd25bf2d1fd916e5d0900fdcee196aa2">&#9670;&nbsp;</a></span>UnlockRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::LockManager::UnlockRow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbustub_1_1Transaction.html">Transaction</a> *&#160;</td>
          <td class="paramname"><em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebustub.html#a3571cdcf7aa43bd929669794e75cbc48">table_oid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbustub_1_1RID.html">RID</a> &amp;&#160;</td>
          <td class="paramname"><em>rid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the lock held on a row by the transaction.</p>
<p>This method should abort the transaction and throw a TransactionAbortException under certain circumstances. See [UNLOCK_NOTE] in header file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txn</td><td>the transaction releasing the lock </td></tr>
    <tr><td class="paramname">rid</td><td>the <a class="el" href="classbustub_1_1RID.html">RID</a> that is locked by the transaction </td></tr>
    <tr><td class="paramname">oid</td><td>the table_oid_t of the table the row belongs to </td></tr>
    <tr><td class="paramname">rid</td><td>the <a class="el" href="classbustub_1_1RID.html">RID</a> of the row to be unlocked </td></tr>
    <tr><td class="paramname">force</td><td>unlock the tuple regardless of isolation level, not changing the transaction state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the unlock is successful, false otherwise </dd></dl>

</div>
</div>
<a id="a89c917de275498c22f53138355787447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c917de275498c22f53138355787447">&#9670;&nbsp;</a></span>UnlockTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::LockManager::UnlockTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbustub_1_1Transaction.html">Transaction</a> *&#160;</td>
          <td class="paramname"><em>txn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacebustub.html#a3571cdcf7aa43bd929669794e75cbc48">table_oid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>oid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the lock held on a table by the transaction.</p>
<p>This method should abort the transaction and throw a TransactionAbortException under certain circumstances. See [UNLOCK_NOTE] in header file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">txn</td><td>the transaction releasing the lock </td></tr>
    <tr><td class="paramname">oid</td><td>the table_oid_t of the table to be unlocked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the unlock is successful, false otherwise </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/include/concurrency/<a class="el" href="lock__manager_8h_source.html">lock_manager.h</a></li>
<li>src/concurrency/lock_manager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
