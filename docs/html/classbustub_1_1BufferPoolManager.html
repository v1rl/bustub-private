<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BusTub: bustub::BufferPoolManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BusTub
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebustub.html">bustub</a></li><li class="navelem"><a class="el" href="classbustub_1_1BufferPoolManager.html">BufferPoolManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbustub_1_1BufferPoolManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bustub::BufferPoolManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The declaration of the <code><a class="el" href="classbustub_1_1BufferPoolManager.html" title="The declaration of the BufferPoolManager class.">BufferPoolManager</a></code> class.  
 <a href="classbustub_1_1BufferPoolManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer__pool__manager_8h_source.html">buffer_pool_manager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a57bba71e14d3c0eb6d73f517a2c6bb05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#a57bba71e14d3c0eb6d73f517a2c6bb05">BufferPoolManager</a> (size_t num_frames, <a class="el" href="classbustub_1_1DiskManager.html">DiskManager</a> *disk_manager, size_t k_dist=LRUK_REPLACER_K, <a class="el" href="classbustub_1_1LogManager.html">LogManager</a> *log_manager=nullptr)</td></tr>
<tr class="memdesc:a57bba71e14d3c0eb6d73f517a2c6bb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code><a class="el" href="classbustub_1_1BufferPoolManager.html" title="The declaration of the BufferPoolManager class.">BufferPoolManager</a></code> instance and initializes all fields.  <a href="classbustub_1_1BufferPoolManager.html#a57bba71e14d3c0eb6d73f517a2c6bb05">More...</a><br /></td></tr>
<tr class="separator:a57bba71e14d3c0eb6d73f517a2c6bb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a4623a5a510f9765e80b6277abb63"><td class="memItemLeft" align="right" valign="top"><a id="ab15a4623a5a510f9765e80b6277abb63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#ab15a4623a5a510f9765e80b6277abb63">~BufferPoolManager</a> ()</td></tr>
<tr class="memdesc:ab15a4623a5a510f9765e80b6277abb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <code><a class="el" href="classbustub_1_1BufferPoolManager.html" title="The declaration of the BufferPoolManager class.">BufferPoolManager</a></code>, freeing up all memory that the buffer pool was using. <br /></td></tr>
<tr class="separator:ab15a4623a5a510f9765e80b6277abb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f8029d466e51f4db7499f20d4a9bc4"><td class="memItemLeft" align="right" valign="top"><a id="a08f8029d466e51f4db7499f20d4a9bc4"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#a08f8029d466e51f4db7499f20d4a9bc4">Size</a> () const -&gt; size_t</td></tr>
<tr class="memdesc:a08f8029d466e51f4db7499f20d4a9bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of frames that this buffer pool manages. <br /></td></tr>
<tr class="separator:a08f8029d466e51f4db7499f20d4a9bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b07e6ba34964dc7142d491ea5584db"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#ab4b07e6ba34964dc7142d491ea5584db">NewPage</a> () -&gt; page_id_t</td></tr>
<tr class="memdesc:ab4b07e6ba34964dc7142d491ea5584db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new page on disk.  <a href="classbustub_1_1BufferPoolManager.html#ab4b07e6ba34964dc7142d491ea5584db">More...</a><br /></td></tr>
<tr class="separator:ab4b07e6ba34964dc7142d491ea5584db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886bf55926262a90d978a8a300c95acb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#a886bf55926262a90d978a8a300c95acb">DeletePage</a> (page_id_t page_id) -&gt; bool</td></tr>
<tr class="memdesc:a886bf55926262a90d978a8a300c95acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a page from the database, both on disk and in memory.  <a href="classbustub_1_1BufferPoolManager.html#a886bf55926262a90d978a8a300c95acb">More...</a><br /></td></tr>
<tr class="separator:a886bf55926262a90d978a8a300c95acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae864655193eb16bd8de42a6b5f5593d4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#ae864655193eb16bd8de42a6b5f5593d4">CheckedWritePage</a> (page_id_t page_id, AccessType access_type=AccessType::Unknown) -&gt; std::optional&lt; <a class="el" href="classbustub_1_1WritePageGuard.html">WritePageGuard</a> &gt;</td></tr>
<tr class="memdesc:ae864655193eb16bd8de42a6b5f5593d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires an optional write-locked guard over a page of data. The user can specify an <code>AccessType</code> if needed.  <a href="classbustub_1_1BufferPoolManager.html#ae864655193eb16bd8de42a6b5f5593d4">More...</a><br /></td></tr>
<tr class="separator:ae864655193eb16bd8de42a6b5f5593d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba342e73ade1e84456bcc718c4342d4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#aaba342e73ade1e84456bcc718c4342d4">CheckedReadPage</a> (page_id_t page_id, AccessType access_type=AccessType::Unknown) -&gt; std::optional&lt; <a class="el" href="classbustub_1_1ReadPageGuard.html">ReadPageGuard</a> &gt;</td></tr>
<tr class="memdesc:aaba342e73ade1e84456bcc718c4342d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires an optional read-locked guard over a page of data. The user can specify an <code>AccessType</code> if needed.  <a href="classbustub_1_1BufferPoolManager.html#aaba342e73ade1e84456bcc718c4342d4">More...</a><br /></td></tr>
<tr class="separator:aaba342e73ade1e84456bcc718c4342d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d2cb1bf882a89e880ef9fde40a3ab7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#a96d2cb1bf882a89e880ef9fde40a3ab7">WritePage</a> (page_id_t page_id, AccessType access_type=AccessType::Unknown) -&gt; <a class="el" href="classbustub_1_1WritePageGuard.html">WritePageGuard</a></td></tr>
<tr class="memdesc:a96d2cb1bf882a89e880ef9fde40a3ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <code>CheckedWritePage</code> that unwraps the inner value if it exists.  <a href="classbustub_1_1BufferPoolManager.html#a96d2cb1bf882a89e880ef9fde40a3ab7">More...</a><br /></td></tr>
<tr class="separator:a96d2cb1bf882a89e880ef9fde40a3ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3406341d9b86e00d08a9244b9cde1962"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#a3406341d9b86e00d08a9244b9cde1962">ReadPage</a> (page_id_t page_id, AccessType access_type=AccessType::Unknown) -&gt; <a class="el" href="classbustub_1_1ReadPageGuard.html">ReadPageGuard</a></td></tr>
<tr class="memdesc:a3406341d9b86e00d08a9244b9cde1962"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <code>CheckedReadPage</code> that unwraps the inner value if it exists.  <a href="classbustub_1_1BufferPoolManager.html#a3406341d9b86e00d08a9244b9cde1962">More...</a><br /></td></tr>
<tr class="separator:a3406341d9b86e00d08a9244b9cde1962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c0a538f36cb3f008e96e1d08c0a246"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#ac1c0a538f36cb3f008e96e1d08c0a246">FlushPageUnsafe</a> (page_id_t page_id) -&gt; bool</td></tr>
<tr class="memdesc:ac1c0a538f36cb3f008e96e1d08c0a246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes a page's data out to disk unsafely.  <a href="classbustub_1_1BufferPoolManager.html#ac1c0a538f36cb3f008e96e1d08c0a246">More...</a><br /></td></tr>
<tr class="separator:ac1c0a538f36cb3f008e96e1d08c0a246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf53d6a03897fd02b0bb9f4a34de5b5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#adbf53d6a03897fd02b0bb9f4a34de5b5">FlushPage</a> (page_id_t page_id) -&gt; bool</td></tr>
<tr class="memdesc:adbf53d6a03897fd02b0bb9f4a34de5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes a page's data out to disk safely.  <a href="classbustub_1_1BufferPoolManager.html#adbf53d6a03897fd02b0bb9f4a34de5b5">More...</a><br /></td></tr>
<tr class="separator:adbf53d6a03897fd02b0bb9f4a34de5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ddc170b34dc9562dd56e481bcd47d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#a51ddc170b34dc9562dd56e481bcd47d3">FlushAllPagesUnsafe</a> ()</td></tr>
<tr class="memdesc:a51ddc170b34dc9562dd56e481bcd47d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all page data that is in memory to disk unsafely.  <a href="classbustub_1_1BufferPoolManager.html#a51ddc170b34dc9562dd56e481bcd47d3">More...</a><br /></td></tr>
<tr class="separator:a51ddc170b34dc9562dd56e481bcd47d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3526a4b3e7aa8469cb595a2a241ffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#a2b3526a4b3e7aa8469cb595a2a241ffa">FlushAllPages</a> ()</td></tr>
<tr class="memdesc:a2b3526a4b3e7aa8469cb595a2a241ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all page data that is in memory to disk safely.  <a href="classbustub_1_1BufferPoolManager.html#a2b3526a4b3e7aa8469cb595a2a241ffa">More...</a><br /></td></tr>
<tr class="separator:a2b3526a4b3e7aa8469cb595a2a241ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348dc976906a575ce1ec8ab228e8d9a0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbustub_1_1BufferPoolManager.html#a348dc976906a575ce1ec8ab228e8d9a0">GetPinCount</a> (page_id_t page_id) -&gt; std::optional&lt; size_t &gt;</td></tr>
<tr class="memdesc:a348dc976906a575ce1ec8ab228e8d9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the pin count of a page. If the page does not exist in memory, return <code>std::nullopt</code>.  <a href="classbustub_1_1BufferPoolManager.html#a348dc976906a575ce1ec8ab228e8d9a0">More...</a><br /></td></tr>
<tr class="separator:a348dc976906a575ce1ec8ab228e8d9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The declaration of the <code><a class="el" href="classbustub_1_1BufferPoolManager.html" title="The declaration of the BufferPoolManager class.">BufferPoolManager</a></code> class. </p>
<p>As stated in the writeup, the buffer pool is responsible for moving physical pages of data back and forth from buffers in main memory to persistent storage. It also behaves as a cache, keeping frequently used pages in memory for faster access, and evicting unused or cold pages back out to storage.</p>
<p>Make sure you read the writeup in its entirety before attempting to implement the buffer pool manager. You also need to have completed the implementation of both the <code><a class="el" href="classbustub_1_1LRUKReplacer.html">LRUKReplacer</a></code> and <code><a class="el" href="classbustub_1_1DiskManager.html">DiskManager</a></code> classes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a57bba71e14d3c0eb6d73f517a2c6bb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bba71e14d3c0eb6d73f517a2c6bb05">&#9670;&nbsp;</a></span>BufferPoolManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bustub::BufferPoolManager::BufferPoolManager </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbustub_1_1DiskManager.html">DiskManager</a> *&#160;</td>
          <td class="paramname"><em>disk_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k_dist</em> = <code>LRUK_REPLACER_K</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbustub_1_1LogManager.html">LogManager</a> *&#160;</td>
          <td class="paramname"><em>log_manager</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code><a class="el" href="classbustub_1_1BufferPoolManager.html" title="The declaration of the BufferPoolManager class.">BufferPoolManager</a></code> instance and initializes all fields. </p>
<p>See the documentation for <code><a class="el" href="classbustub_1_1BufferPoolManager.html" title="The declaration of the BufferPoolManager class.">BufferPoolManager</a></code> in "buffer/buffer_pool_manager.h" for more information.</p>
<h3><a class="anchor" id="autotoc_md0"></a>
Implementation</h3>
<p>We have implemented the constructor for you in a way that makes sense with our reference solution. You are free to change anything you would like here if it doesn't fit with you implementation.</p>
<p>Be warned, though! If you stray too far away from our guidance, it will be much harder for us to help you. Our recommendation would be to first implement the buffer pool manager using the stepping stones we have provided.</p>
<p>Once you have a fully working solution (all Gradescope test cases pass), then you can try more interesting things!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_frames</td><td>The size of the buffer pool. </td></tr>
    <tr><td class="paramname">disk_manager</td><td>The disk manager. </td></tr>
    <tr><td class="paramname">k_dist</td><td>The backward k-distance for the LRU-K replacer. </td></tr>
    <tr><td class="paramname">log_manager</td><td>The log manager. Please ignore this for P1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaba342e73ade1e84456bcc718c4342d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba342e73ade1e84456bcc718c4342d4">&#9670;&nbsp;</a></span>CheckedReadPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::CheckedReadPage </td>
          <td>(</td>
          <td class="paramtype">page_id_t&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessType&#160;</td>
          <td class="paramname"><em>access_type</em> = <code>AccessType::Unknown</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::optional&lt;<a class="el" href="classbustub_1_1ReadPageGuard.html">ReadPageGuard</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires an optional read-locked guard over a page of data. The user can specify an <code>AccessType</code> if needed. </p>
<p>If it is not possible to bring the page of data into memory, this function will return a <code>std::nullopt</code>.</p>
<p><a class="el" href="classbustub_1_1Page.html" title="TODO(2024 tas) This entire class needs to be updated.">Page</a> data can <em>only</em> be accessed via page guards. Users of this <code><a class="el" href="classbustub_1_1BufferPoolManager.html" title="The declaration of the BufferPoolManager class.">BufferPoolManager</a></code> are expected to acquire either a <code><a class="el" href="classbustub_1_1ReadPageGuard.html" title="An RAII object that grants thread-safe read access to a page of data.">ReadPageGuard</a></code> or a <code><a class="el" href="classbustub_1_1WritePageGuard.html" title="An RAII object that grants thread-safe write access to a page of data.">WritePageGuard</a></code> depending on the mode in which they would like to access the data, which ensures that any access of data is thread-safe.</p>
<p>There can be any number of <code><a class="el" href="classbustub_1_1ReadPageGuard.html" title="An RAII object that grants thread-safe read access to a page of data.">ReadPageGuard</a></code>s reading the same page of data at a time across different threads. However, all data access must be immutable. If a user wants to mutate the page's data, they must acquire a <code><a class="el" href="classbustub_1_1WritePageGuard.html" title="An RAII object that grants thread-safe write access to a page of data.">WritePageGuard</a></code> with <code>CheckedWritePage</code> instead.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Implementation</h3>
<p>See the implementation details of <code>CheckedWritePage</code>.</p>
<p>TODO(P1): Add implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>The ID of the page we want to read. </td></tr>
    <tr><td class="paramname">access_type</td><td>The type of page access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;ReadPageGuard&gt; An optional latch guard where if there are no more free frames (out of memory) returns <code>std::nullopt</code>, otherwise returns a <code><a class="el" href="classbustub_1_1ReadPageGuard.html" title="An RAII object that grants thread-safe read access to a page of data.">ReadPageGuard</a></code> ensuring shared and read-only access to a page's data. </dd></dl>

</div>
</div>
<a id="ae864655193eb16bd8de42a6b5f5593d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae864655193eb16bd8de42a6b5f5593d4">&#9670;&nbsp;</a></span>CheckedWritePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::CheckedWritePage </td>
          <td>(</td>
          <td class="paramtype">page_id_t&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessType&#160;</td>
          <td class="paramname"><em>access_type</em> = <code>AccessType::Unknown</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::optional&lt;<a class="el" href="classbustub_1_1WritePageGuard.html">WritePageGuard</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires an optional write-locked guard over a page of data. The user can specify an <code>AccessType</code> if needed. </p>
<p>If it is not possible to bring the page of data into memory, this function will return a <code>std::nullopt</code>.</p>
<p><a class="el" href="classbustub_1_1Page.html" title="TODO(2024 tas) This entire class needs to be updated.">Page</a> data can <em>only</em> be accessed via page guards. Users of this <code><a class="el" href="classbustub_1_1BufferPoolManager.html" title="The declaration of the BufferPoolManager class.">BufferPoolManager</a></code> are expected to acquire either a <code><a class="el" href="classbustub_1_1ReadPageGuard.html" title="An RAII object that grants thread-safe read access to a page of data.">ReadPageGuard</a></code> or a <code><a class="el" href="classbustub_1_1WritePageGuard.html" title="An RAII object that grants thread-safe write access to a page of data.">WritePageGuard</a></code> depending on the mode in which they would like to access the data, which ensures that any access of data is thread-safe.</p>
<p>There can only be 1 <code><a class="el" href="classbustub_1_1WritePageGuard.html" title="An RAII object that grants thread-safe write access to a page of data.">WritePageGuard</a></code> reading/writing a page at a time. This allows data access to be both immutable and mutable, meaning the thread that owns the <code><a class="el" href="classbustub_1_1WritePageGuard.html" title="An RAII object that grants thread-safe write access to a page of data.">WritePageGuard</a></code> is allowed to manipulate the page's data however they want. If a user wants to have multiple threads reading the page at the same time, they must acquire a <code><a class="el" href="classbustub_1_1ReadPageGuard.html" title="An RAII object that grants thread-safe read access to a page of data.">ReadPageGuard</a></code> with <code>CheckedReadPage</code> instead.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Implementation</h3>
<p>There are 3 main cases that you will have to implement. The first two are relatively simple: one is when there is plenty of available memory, and the other is when we don't actually need to perform any additional I/O. Think about what exactly these two cases entail.</p>
<p>The third case is the trickiest, and it is when we do not have any <em>easily</em> available memory at our disposal. The buffer pool is tasked with finding memory that it can use to bring in a page of memory, using the replacement algorithm you implemented previously to find candidate frames for eviction.</p>
<p>Once the buffer pool has identified a frame for eviction, several I/O operations may be necessary to bring in the page of data we want into the frame.</p>
<p>There is likely going to be a lot of shared code with <code>CheckedReadPage</code>, so you may find creating helper functions useful.</p>
<p>These two functions are the crux of this project, so we won't give you more hints than this. Good luck!</p>
<p>TODO(P1): Add implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>The ID of the page we want to write to. </td></tr>
    <tr><td class="paramname">access_type</td><td>The type of page access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;WritePageGuard&gt; An optional latch guard where if there are no more free frames (out of memory) returns <code>std::nullopt</code>, otherwise returns a <code><a class="el" href="classbustub_1_1WritePageGuard.html" title="An RAII object that grants thread-safe write access to a page of data.">WritePageGuard</a></code> ensuring exclusive and mutable access to a page's data. </dd></dl>

</div>
</div>
<a id="a886bf55926262a90d978a8a300c95acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886bf55926262a90d978a8a300c95acb">&#9670;&nbsp;</a></span>DeletePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::DeletePage </td>
          <td>(</td>
          <td class="paramtype">page_id_t&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a page from the database, both on disk and in memory. </p>
<p>If the page is pinned in the buffer pool, this function does nothing and returns <code>false</code>. Otherwise, this function removes the page from both disk and memory (if it is still in the buffer pool), returning <code>true</code>.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Implementation</h3>
<p>Think about all of the places a page or a page's metadata could be, and use that to guide you on implementing this function. You will probably want to implement this function <em>after</em> you have implemented <code>CheckedReadPage</code> and <code>CheckedWritePage</code>.</p>
<p>You should call <code>DeallocatePage</code> in the disk scheduler to make the space available for new pages.</p>
<p>TODO(P1): Add implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>The page ID of the page we want to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the page exists but could not be deleted, <code>true</code> if the page didn't exist or deletion succeeded. </dd></dl>

</div>
</div>
<a id="a2b3526a4b3e7aa8469cb595a2a241ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3526a4b3e7aa8469cb595a2a241ffa">&#9670;&nbsp;</a></span>FlushAllPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bustub::BufferPoolManager::FlushAllPages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes all page data that is in memory to disk safely. </p>
<p>You should take locks on the pages in this function to ensure that a consistent state is flushed to disk.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Implementation</h3>
<p>You should probably leave implementing this function until after you have completed <code>CheckedReadPage</code>, <code>CheckedWritePage</code>, and <code>FlushPage</code>, as it will likely be much easier to understand what to do.</p>
<p>TODO(P1): Add implementation </p>

</div>
</div>
<a id="a51ddc170b34dc9562dd56e481bcd47d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ddc170b34dc9562dd56e481bcd47d3">&#9670;&nbsp;</a></span>FlushAllPagesUnsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bustub::BufferPoolManager::FlushAllPagesUnsafe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes all page data that is in memory to disk unsafely. </p>
<p>You should not take locks on the pages in this function. This means that you should carefully consider when to toggle the <code>is_dirty_</code> bit.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Implementation</h3>
<p>You should probably leave implementing this function until after you have completed <code>CheckedReadPage</code>, <code>CheckedWritePage</code>, and <code>FlushPage</code>, as it will likely be much easier to understand what to do.</p>
<p>TODO(P1): Add implementation </p>

</div>
</div>
<a id="adbf53d6a03897fd02b0bb9f4a34de5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf53d6a03897fd02b0bb9f4a34de5b5">&#9670;&nbsp;</a></span>FlushPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::FlushPage </td>
          <td>(</td>
          <td class="paramtype">page_id_t&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes a page's data out to disk safely. </p>
<p>This function will write out a page's data to disk if it has been modified. If the given page is not in memory, this function will return <code>false</code>.</p>
<p>You should take a lock on the page in this function to ensure that a consistent state is flushed to disk.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Implementation</h3>
<p>You should probably leave implementing this function until after you have completed <code>CheckedReadPage</code>, <code>CheckedWritePage</code>, and <code>Flush</code> in the page guards, as it will likely be much easier to understand what to do.</p>
<p>TODO(P1): Add implementation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>The page ID of the page to be flushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the page could not be found in the page table, otherwise <code>true</code>. </dd></dl>

</div>
</div>
<a id="ac1c0a538f36cb3f008e96e1d08c0a246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c0a538f36cb3f008e96e1d08c0a246">&#9670;&nbsp;</a></span>FlushPageUnsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::FlushPageUnsafe </td>
          <td>(</td>
          <td class="paramtype">page_id_t&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes a page's data out to disk unsafely. </p>
<p>This function will write out a page's data to disk if it has been modified. If the given page is not in memory, this function will return <code>false</code>.</p>
<p>You should not take a lock on the page in this function. This means that you should carefully consider when to toggle the <code>is_dirty_</code> bit.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Implementation</h3>
<p>You should probably leave implementing this function until after you have completed <code>CheckedReadPage</code> and <code>CheckedWritePage</code>, as it will likely be much easier to understand what to do.</p>
<p>TODO(P1): Add implementation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>The page ID of the page to be flushed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the page could not be found in the page table, otherwise <code>true</code>. </dd></dl>

</div>
</div>
<a id="a348dc976906a575ce1ec8ab228e8d9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348dc976906a575ce1ec8ab228e8d9a0">&#9670;&nbsp;</a></span>GetPinCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::GetPinCount </td>
          <td>(</td>
          <td class="paramtype">page_id_t&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td> -&gt; std::optional&lt;size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the pin count of a page. If the page does not exist in memory, return <code>std::nullopt</code>. </p>
<p>This function is thread safe. Callers may invoke this function in a multi-threaded environment where multiple threads access the same page.</p>
<p>This function is intended for testing purposes. If this function is implemented incorrectly, it will definitely cause problems with the test suite and autograder.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Implementation</h1>
<p>We will use this function to test if your buffer pool manager is managing pin counts correctly. Since the <code>pin_count_</code> field in <code><a class="el" href="classbustub_1_1FrameHeader.html" title="A helper class for BufferPoolManager that manages a frame of memory and related metadata.">FrameHeader</a></code> is an atomic type, you do not need to take the latch on the frame that holds the page we want to look at. Instead, you can simply use an atomic <code>load</code> to safely load the value stored. You will still need to take the buffer pool latch, however.</p>
<p>Again, if you are unfamiliar with atomic types, see the official C++ docs <a href="https://en.cppreference.com/w/cpp/atomic/atomic">here</a>.</p>
<p>TODO(P1): Add implementation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>The page ID of the page we want to get the pin count of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;size_t&gt; The pin count if the page exists, otherwise <code>std::nullopt</code>. </dd></dl>

</div>
</div>
<a id="ab4b07e6ba34964dc7142d491ea5584db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b07e6ba34964dc7142d491ea5584db">&#9670;&nbsp;</a></span>NewPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::NewPage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; page_id_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new page on disk. </p>
<h3><a class="anchor" id="autotoc_md1"></a>
Implementation</h3>
<p>You will maintain a thread-safe, monotonically increasing counter in the form of a <code>std::atomic&lt;page_id_t&gt;</code>. See the documentation on <a href="https://en.cppreference.com/w/cpp/atomic/atomic">atomics</a> for more information.</p>
<p>TODO(P1): Add implementation.</p>
<dl class="section return"><dt>Returns</dt><dd>The page ID of the newly allocated page. </dd></dl>

</div>
</div>
<a id="a3406341d9b86e00d08a9244b9cde1962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3406341d9b86e00d08a9244b9cde1962">&#9670;&nbsp;</a></span>ReadPage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::ReadPage </td>
          <td>(</td>
          <td class="paramtype">page_id_t&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessType&#160;</td>
          <td class="paramname"><em>access_type</em> = <code>AccessType::Unknown</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classbustub_1_1ReadPageGuard.html">ReadPageGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper around <code>CheckedReadPage</code> that unwraps the inner value if it exists. </p>
<p>If <code>CheckedReadPage</code> returns a <code>std::nullopt</code>, <b>this function aborts the entire process.</b></p>
<p>This function should <b>only</b> be used for testing and ergonomic's sake. If it is at all possible that the buffer pool manager might run out of memory, then use <code>CheckedPageWrite</code> to allow you to handle that case.</p>
<p>See the documentation for <code>CheckedPageRead</code> for more information about implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>The ID of the page we want to read. </td></tr>
    <tr><td class="paramname">access_type</td><td>The type of page access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classbustub_1_1ReadPageGuard.html" title="An RAII object that grants thread-safe read access to a page of data.">ReadPageGuard</a> A page guard ensuring shared and read-only access to a page's data. </dd></dl>

</div>
</div>
<a id="a96d2cb1bf882a89e880ef9fde40a3ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d2cb1bf882a89e880ef9fde40a3ab7">&#9670;&nbsp;</a></span>WritePage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto bustub::BufferPoolManager::WritePage </td>
          <td>(</td>
          <td class="paramtype">page_id_t&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessType&#160;</td>
          <td class="paramname"><em>access_type</em> = <code>AccessType::Unknown</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classbustub_1_1WritePageGuard.html">WritePageGuard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper around <code>CheckedWritePage</code> that unwraps the inner value if it exists. </p>
<p>If <code>CheckedWritePage</code> returns a <code>std::nullopt</code>, <b>this function aborts the entire process.</b></p>
<p>This function should <b>only</b> be used for testing and ergonomic's sake. If it is at all possible that the buffer pool manager might run out of memory, then use <code>CheckedPageWrite</code> to allow you to handle that case.</p>
<p>See the documentation for <code>CheckedPageWrite</code> for more information about implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_id</td><td>The ID of the page we want to read. </td></tr>
    <tr><td class="paramname">access_type</td><td>The type of page access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classbustub_1_1WritePageGuard.html" title="An RAII object that grants thread-safe write access to a page of data.">WritePageGuard</a> A page guard ensuring exclusive and mutable access to a page's data. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/include/buffer/<a class="el" href="buffer__pool__manager_8h_source.html">buffer_pool_manager.h</a></li>
<li>src/buffer/buffer_pool_manager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
